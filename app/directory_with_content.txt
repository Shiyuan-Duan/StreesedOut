Directory Structure:

app/
    fear-conditioning.js
    describe.py
    directory_with_content.txt
    +not-found.tsx
    auditory-oddball.js
    mist-question.js
    _layout.tsx
    motor-imagery.js
    mental-relaxation.js
    ema-questionnaire.js
    constants/
        index.js
        ble.js
        api.js
    (tabs)/
        ParadigmSelectionScreen.js
        index.tsx
        devices.tsx
        _layout.tsx
        explore.tsx
    utils/
        ImageManager.js
    components/
        DeviceCard.js
        AddDeviceModal.js
    services/
        bleServices.js
        ble_characteristics.js


Files with '.js' or '.tsx' extensions and their content:

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/fear-conditioning.js
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Image, TouchableOpacity, Animated, Easing } from 'react-native';
import { useNavigation, useFocusEffect } from '@react-navigation/native';
import images from './utils/ImageManager'; // Import images from ImageManager.js

export default function FearConditioningScreen() {
  const navigation = useNavigation();

  const [step, setStep] = useState('start'); // Current step: 'start', 'countdown', 'images', 'break', 'end'
  const [countdown, setCountdown] = useState(15); // Countdown timer for 'countdown' step
  const [currentImageIndex, setCurrentImageIndex] = useState(0); // Index of the current image in the set
  const [currentSequenceIndex, setCurrentSequenceIndex] = useState(0); // Index of the current play sequence
  const [imageSet, setImageSet] = useState([]); // Current set of images to display
  const [timeLeft, setTimeLeft] = useState(0); // Timer for 'break' step
  const [headerVisible, setHeaderVisible] = useState(false); // Controls header visibility
  const [buttonOpacity] = useState(new Animated.Value(1)); // For button fade-in effect

  const IMAGE_DISPLAY_DURATION = 2000; // 2 seconds per image
  const BREAK_DURATION = 10; // 10 seconds break (in seconds)

  // Hard-coded play sequence
  const playSequence = [
    { category: 'Fear', set: 'Set 1' },
    { category: 'Happy', set: 'Set 3' },
    { category: 'Fear', set: 'Set 2' },
    { category: 'Happy', set: 'Set 4' },
    { category: 'Fear', set: 'Set 3' },
  ];

  // Hide or show the navigation header
  useEffect(() => {
    navigation.setOptions({
      headerShown: headerVisible,
    });
  }, [headerVisible]);

  // Show header on screen tap and hide after 3 seconds
  const headerTimeoutRef = useRef(null);

  const handleScreenTap = () => {
    if (step === 'images') {
      setHeaderVisible(true);

      if (headerTimeoutRef.current) {
        clearTimeout(headerTimeoutRef.current);
      }

      headerTimeoutRef.current = setTimeout(() => {
        setHeaderVisible(false);
      }, 3000);
    }
  };

  // Load the next image set when the sequence changes
  useEffect(() => {
    if (currentSequenceIndex < playSequence.length) {
      const { category, set } = playSequence[currentSequenceIndex];
      setImageSet(shuffle(images[category][set])); // Shuffle images in the set
    } else {
      setStep('end');
    }
  }, [currentSequenceIndex]);

  // Handle transitions based on the current step
  useEffect(() => {
    let timer;

    switch (step) {
      case 'countdown':
        if (countdown > 0) {
          timer = setTimeout(() => setCountdown((prev) => prev - 1), 1000);
        } else {
          setStep('images');
          setCurrentImageIndex(0); // Reset the image index
          setHeaderVisible(false); // Ensure header is hidden
        }
        break;

      case 'images':
        if (currentImageIndex < imageSet.length) {
          timer = setTimeout(() => setCurrentImageIndex((prev) => prev + 1), IMAGE_DISPLAY_DURATION);
        } else {
          setStep('break');
          setTimeLeft(BREAK_DURATION);
        }
        break;

      case 'break':
        if (timeLeft > 0) {
          timer = setTimeout(() => setTimeLeft((prev) => prev - 1), 1000);
        } else {
          setCurrentSequenceIndex((prev) => prev + 1); // Move to the next sequence
          setStep('countdown');
          setCountdown(5); // Reset the countdown
        }
        break;

      default:
        break;
    }

    return () => clearTimeout(timer); // Clear the timer when the step changes
  }, [step, countdown, currentImageIndex, timeLeft]);

  // Clean up header timeout when component unmounts
  useEffect(() => {
    return () => {
      if (headerTimeoutRef.current) {
        clearTimeout(headerTimeoutRef.current);
      }
    };
  }, []);

  // Fade-in animation for the start button
  useEffect(() => {
    Animated.timing(buttonOpacity, {
      toValue: 1,
      duration: 1000,
      easing: Easing.inOut(Easing.ease),
      useNativeDriver: true,
    }).start();
  }, []);

  // Shuffle an array
  function shuffle(array) {
    return array.sort(() => Math.random() - 0.5);
  }

  return (
    <View style={styles.container}>
      <TouchableOpacity style={styles.fullScreenTouchable} onPress={handleScreenTap} activeOpacity={1}>
        <View style={styles.content}>
          {step === 'start' && (
            <Animated.View style={[styles.buttonContainer, { opacity: buttonOpacity }]}>
              <TouchableOpacity style={styles.startButton} onPress={() => setStep('countdown')}>
                <Text style={styles.buttonText}>Start</Text>
              </TouchableOpacity>
            </Animated.View>
          )}
          {step === 'countdown' && (
            <Text style={styles.countdownText}>Starting in... {countdown} seconds</Text>
          )}
          {step === 'images' && imageSet.length > 0 && (
            <Image
              source={imageSet[currentImageIndex]}
              style={styles.image}
              resizeMode="contain"
            />
          )}
          {step === 'break' && (
            <Text style={styles.breakText}>Take a break... {timeLeft} seconds remaining</Text>
          )}
          {step === 'end' && (
            <Text style={styles.endText}>The session is complete. Thank you!</Text>
          )}
        </View>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: 'black', // Ensure background is completely black
  },
  fullScreenTouchable: {
    flex: 1,
    width: '100%',
  },
  content: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center', // Center content vertically
  },
  countdownText: {
    fontSize: 30,
    fontWeight: 'bold',
    color: '#FFFFFF', // White text for visibility on black background
    textAlign: 'center',
  },
  breakText: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFFFFF',
    textAlign: 'center',
  },
  endText: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFFFFF',
    textAlign: 'center',
  },
  image: {
    width: '100%',
    height: '100%',
  },
  buttonContainer: {
    // Optional styling for the button container
  },
  startButton: {
    backgroundColor: '#4682B4', // Steel blue color
    paddingVertical: 15,
    paddingHorizontal: 30,
    borderRadius: 8,
    elevation: 3, // Add shadow for Android
    shadowColor: '#000', // Shadow for iOS
    shadowOffset: { width: 0, height: 2 }, // Shadow for iOS
    shadowOpacity: 0.25, // Shadow for iOS
    shadowRadius: 3.84, // Shadow for iOS
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 20,
    fontWeight: 'bold',
  },
});

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/+not-found.tsx
================================================================================
import { Link, Stack } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <ThemedView style={styles.container}>
        <ThemedText type="title">This screen doesn't exist.</ThemedText>
        <Link href="/" style={styles.link}>
          <ThemedText type="link">Go to home screen!</ThemedText>
        </Link>
      </ThemedView>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/auditory-oddball.js
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Dimensions,
  Alert,
  ScrollView,
} from 'react-native';
import { Audio } from 'expo-av';
import { MaterialCommunityIcons } from '@expo/vector-icons';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

export default function AuditoryOddballScreen() {
  const [step, setStep] = useState('introduction'); // 'introduction', 'task', 'questionnaire', 'completion'
  const [timeLeft, setTimeLeft] = useState(600); // 10 minutes in seconds
  const [isPlaying, setIsPlaying] = useState(false);
  const [responseCount, setResponseCount] = useState(0);
  const [responses, setResponses] = useState({
    stressLevel: null,
  });

  const standardTone = useRef(new Audio.Sound());
  const deviantTone = useRef(new Audio.Sound());
  const toneIntervalRef = useRef(null);
  const timerRef = useRef(null);

  // Load the audio files
  useEffect(() => {
    const loadSounds = async () => {
      try {
        await standardTone.current.loadAsync(require('../assets/1000.wav'));
        await deviantTone.current.loadAsync(require('../assets/1500.wav'));
      } catch (error) {
        console.error('Error loading sounds:', error);
      }
    };

    loadSounds();

    // Unload sounds on unmount
    return () => {
      standardTone.current.unloadAsync();
      deviantTone.current.unloadAsync();
    };
  }, []);

  // Start the task timer
  useEffect(() => {
    if (step === 'task') {
      setIsPlaying(true);

      timerRef.current = setInterval(() => {
        setTimeLeft((prevTime) => {
          if (prevTime <= 1) {
            clearInterval(timerRef.current);
            clearInterval(toneIntervalRef.current);
            setIsPlaying(false);
            setStep('questionnaire');
            return 0;
          }
          return prevTime - 1;
        });
      }, 1000);

      // Play tones at intervals
      toneIntervalRef.current = setInterval(() => {
        playTone();
      }, 2000); // Play a tone every 2 seconds

      // Cleanup on unmount
      return () => {
        clearInterval(timerRef.current);
        clearInterval(toneIntervalRef.current);
      };
    }
  }, [step]);

  const playTone = async () => {
    // Randomly decide whether to play standard or deviant tone
    const isDeviant = Math.random() < 0.2; // 20% probability
    try {
      // Stop any currently playing sounds
      await standardTone.current.stopAsync().catch(() => {});
      await deviantTone.current.stopAsync().catch(() => {});

      if (isDeviant) {
        await deviantTone.current.replayAsync();
      } else {
        await standardTone.current.replayAsync();
      }
    } catch (error) {
      console.error('Error playing tone:', error);
    }
  };

  const handleUserResponse = () => {
    // Increment response count
    setResponseCount((prevCount) => prevCount + 1);
    // Provide feedback (optional)
    Alert.alert('Response Recorded', 'You pressed the button.');
  };

  const handleSubmit = async () => {
    const data = {
      paradigm: 'AuditoryOddball',
      ambulatoryUUID: 'dummy',
      time: new Date().toISOString(),
      responses,
      responseCount,
    };

    try {
      const response = await fetch('http://localhost:3000/submit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (response.ok) {
        console.log('Data submitted successfully');
        Alert.alert('Success', 'Your responses have been submitted.');
        setStep('completion');
      } else {
        console.error('Error submitting data');
        Alert.alert('Error', 'There was a problem submitting your responses.');
      }
    } catch (error) {
      console.error('Network error:', error);
      Alert.alert('Error', 'Network error occurred while submitting your responses.');
    }
  };

  const isFormComplete = Object.values(responses).every((value) => value !== null);

  return (
    <View style={styles.container}>
      {step === 'introduction' && (
        <View style={styles.content}>
          <Text style={styles.title}>Auditory Oddball Task</Text>
          <Text style={styles.description}>
            In this task, you'll hear a series of tones. Press the button whenever you hear the higher-pitched tone.
          </Text>
          <TouchableOpacity style={styles.button} onPress={() => setStep('task')}>
            <Text style={styles.buttonText}>Start Task</Text>
          </TouchableOpacity>
        </View>
      )}

      {step === 'task' && (
        <View style={styles.content}>
          <Text style={styles.title}>Listen Carefully</Text>
          <Text style={styles.description}>
            Press the button below whenever you hear the deviant tone.
          </Text>
          <Text style={styles.timer}>
            Time Left: {Math.floor(timeLeft / 60)}:{String(timeLeft % 60).padStart(2, '0')}
          </Text>
          <TouchableOpacity style={styles.responseButton} onPress={handleUserResponse}>
            <Text style={styles.responseButtonText}>Press when you hear the deviant tone</Text>
          </TouchableOpacity>
        </View>
      )}

      {step === 'questionnaire' && (
        <ScrollView contentContainerStyle={styles.content} showsVerticalScrollIndicator={false}>
          <Text style={styles.title}>Self-Report Questionnaire</Text>
          <View style={styles.questionContainer}>
            <Text style={styles.questionText}>How stressed do you feel now?</Text>
            <RatingScale
              questionKey="stressLevel"
              response={responses.stressLevel}
              onPress={(key, rating) => {
                setResponses((prev) => ({ ...prev, [key]: rating }));
              }}
            />
          </View>

          {/* Submit Button */}
          <TouchableOpacity
            style={[styles.submitButton, !isFormComplete && styles.disabledButton]}
            onPress={handleSubmit}
            disabled={!isFormComplete}
          >
            <Text style={styles.submitButtonText}>Submit</Text>
          </TouchableOpacity>
        </ScrollView>
      )}

      {step === 'completion' && (
        <View style={styles.content}>
          <Text style={styles.title}>Thank You!</Text>
          <Text style={styles.description}>
            Your responses have been recorded. We appreciate your participation.
          </Text>
        </View>
      )}
    </View>
  );
}

// RatingScale Component
function RatingScale({ questionKey, response, onPress }) {
  const stressLevels = [
    { level: 0, icon: 'emoticon-sad-outline', color: '#F44336' },
    { level: 1, icon: 'emoticon-neutral-outline', color: '#FF9800' },
    { level: 2, icon: 'emoticon-happy-outline', color: '#FFEB3B' },
    { level: 3, icon: 'emoticon-excited-outline', color: '#8BC34A' },
    { level: 4, icon: 'emoticon-cool-outline', color: '#4CAF50' },
  ];

  return (
    <View style={styles.ratingContainer}>
      {stressLevels.map((item) => (
        <TouchableOpacity
          key={item.level}
          style={styles.iconContainer}
          onPress={() => onPress(questionKey, item.level)}
        >
          <MaterialCommunityIcons
            name={item.icon}
            size={50}
            color={response === item.level ? item.color : '#d3d3d3'}
          />
          <Text style={styles.ratingLabel}>{item.level}</Text>
        </TouchableOpacity>
      ))}
    </View>
  );
}

const styles = StyleSheet.create({
    // Container styles
    container: {
      flex: 1,
      backgroundColor: '#f8f9fa',
    },
    content: {
      flex: 1,
      paddingVertical: 20,
      alignItems: 'center', // Center horizontally
      paddingHorizontal: 20,
      paddingTop:50,
    //   justifyContent: 'center', // Center vertically
    },
    // Text styles
    title: {
      fontSize: 28,
      fontWeight: 'bold',
      color: '#333',
      textAlign: 'center',
      marginBottom: 20,
    },
    description: {
      fontSize: 18,
      color: '#555',
      textAlign: 'center',
      marginBottom: 30,
    },
    timer: {
      fontSize: 18,
      color: '#777',
      textAlign: 'center',
      marginBottom: 20,
    },
    // Button styles
    button: {
      backgroundColor: '#4682B4',
      paddingVertical: 15,
      paddingHorizontal: 30,
      borderRadius: 5,
      marginTop: 30,
    },
    buttonText: {
      color: '#fff',
      fontSize: 20,
      fontWeight: 'bold',
    },
    responseButton: {
      backgroundColor: '#FF9800',
      paddingVertical: 15,
      paddingHorizontal: 20,
      borderRadius: 5,
      marginTop: 20,
    },
    responseButtonText: {
      color: '#fff',
      fontSize: 18,
      textAlign: 'center',
    },
    // Questionnaire styles
    questionContainer: {
      marginBottom: 40,
      width: '100%',
      alignItems: 'center',
    },
    questionText: {
      fontSize: 20,
      color: '#333',
      textAlign: 'center',
      marginBottom: 20,
    },
    // Rating styles
    ratingContainer: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      width: SCREEN_WIDTH * 0.9,
    },
    iconContainer: {
      alignItems: 'center',
    },
    ratingLabel: {
      marginTop: 5,
      fontSize: 14,
      color: '#333',
    },
    // Submit button styles
    submitButton: {
      backgroundColor: '#4682B4',
      paddingVertical: 15,
      paddingHorizontal: 30,
      borderRadius: 5,
      marginTop: 20,
      marginBottom: 40,
    },
    disabledButton: {
      backgroundColor: '#A9A9A9', // Gray color to indicate disabled state
    },
    submitButtonText: {
      color: '#fff',
      fontSize: 18,
      fontWeight: 'bold',
      textAlign: 'center',
    },
  });
  
================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/mist-question.js
================================================================================
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Dimensions,
  Alert,
  TextInput,
  KeyboardAvoidingView,
  Platform,
  Vibration,
} from 'react-native';
import { Audio } from 'expo-av'; // Import Audio from expo-av

const { width: SCREEN_WIDTH } = Dimensions.get('window');

export default function MISTScreen() {
  // State variables
  const [step, setStep] = useState('introduction'); // 'introduction', 'task', 'completion', 'questionnaire'
  const [conditionIndex, setConditionIndex] = useState(0); // 0: withoutTimeConstraints, 1: withTimeConstraints
  const [difficultyIndex, setDifficultyIndex] = useState(0); // 0: low, 1: medium, 2: high
  const [trialIndex, setTrialIndex] = useState(0); // 0 to 4
  const [equationIndex, setEquationIndex] = useState(0); // 0 to 4
  const [problems, setProblems] = useState([]);
  const [currentProblem, setCurrentProblem] = useState(null);
  const [userAnswer, setUserAnswer] = useState('');
  const [startTime, setStartTime] = useState(null);
  const [results, setResults] = useState([]);
  const [timerRef, setTimerRef] = useState(null);
  const [timeRemaining, setTimeRemaining] = useState(null);

  // New state variables for questionnaire
  const [stressResponse, setStressResponse] = useState(null);
  const [taskStartTime, setTaskStartTime] = useState(null); // To record the start time of the task

  // Sound and vibration
  const [sound, setSound] = useState();

  const conditions = ['withoutTimeConstraints', 'withTimeConstraints'];
  const difficulties = ['low', 'medium', 'high'];

  // Generate problems upon starting a new trial
  useEffect(() => {
    if (step === 'task') {
      const generatedProblems = generateProblemsForTrial(difficulties[difficultyIndex]);
      setProblems(generatedProblems);
      setEquationIndex(0);
    }
  }, [step, trialIndex, difficultyIndex, conditionIndex]);

  // Update currentProblem when equationIndex or problems change
  useEffect(() => {
    if (problems.length === 0) return; // Guard clause to prevent premature execution

    if (equationIndex < problems.length) {
      setCurrentProblem(problems[equationIndex]);
      setUserAnswer(''); // Clear previous user input
      setStartTime(new Date()); // Reset start time for the new problem

      if (conditions[conditionIndex] === 'withTimeConstraints') {
        resetTimer();
      }
    } else {
      // All problems in the trial are completed
      setCurrentProblem(null);
      if (conditions[conditionIndex] === 'withTimeConstraints') {
        clearTimer();
      }
      moveToNextTrialOrDifficulty();
    }
  }, [equationIndex, problems]);

  // Cleanup function for timers and sounds
  useEffect(() => {
    return () => {
      clearTimer();
      if (sound) {
        sound.unloadAsync();
      }
    };
  }, []);

  const clearTimer = () => {
    if (timerRef) {
      clearInterval(timerRef);
      setTimerRef(null);
    }
  };

  const generateProblemsForTrial = (difficultyLevel) => {
    const generatedProblems = [];
    const equationsPerTrial = 5; // 5 equations per trial
    for (let i = 0; i < equationsPerTrial; i++) {
      switch (difficultyLevel) {
        case 'low':
          generatedProblems.push(generateLowStressProblem());
          break;
        case 'medium':
          generatedProblems.push(generateMediumStressProblem());
          break;
        case 'high':
          generatedProblems.push(generateHighStressProblem());
          break;
        default:
          break;
      }
    }
    return generatedProblems;
  };

  const generateLowStressProblem = () => {
    // Two operations (addition/subtraction) with single-digit numbers, ensuring positive answers
    const operations = ['+', '-'];
    let num1 = getRandomInt(1, 9);
    let num2 = getRandomInt(1, 9);
    let op1 = operations[Math.floor(Math.random() * operations.length)];

    // Adjust to prevent negative answers
    if (op1 === '-' && num1 < num2) {
      [num1, num2] = [num2, num1]; // Swap numbers
    }

    const expression = `${num1} ${op1} ${num2}`;
    const answer = eval(expression);

    return { expression, answer };
  };

  const generateMediumStressProblem = () => {
    // Three operations (addition/subtraction/multiplication) with double and single-digit numbers, ensuring positive answers
    const operations = ['+', '-', '*'];
    let num1 = getRandomInt(10, 99);
    let num2 = getRandomInt(1, 9);
    let num3 = getRandomInt(1, 9);
    let op1 = operations[Math.floor(Math.random() * operations.length)];
    let op2 = operations[Math.floor(Math.random() * operations.length)];

    // Build expression step by step to ensure positive intermediate results
    let expression = `${num1} ${op1} ${num2}`;
    let intermediateResult = eval(expression);

    if (op2 === '-') {
      // Ensure the result does not become negative
      if (intermediateResult < num3) {
        [intermediateResult, num3] = [num3, intermediateResult];
        expression = `${num3} - ${intermediateResult}`;
      } else {
        expression += ` - ${num3}`;
      }
    } else {
      expression += ` ${op2} ${num3}`;
    }

    const answer = eval(expression);

    return { expression, answer };
  };

  const generateHighStressProblem = () => {
    // Four operations (addition/subtraction/multiplication/division) with double and single-digit numbers, ensuring positive answers
    const operations = ['+', '-', '*', '/'];
    let num1 = getRandomInt(10, 99);
    let num2 = getRandomInt(1, 9);
    let num3 = getRandomInt(1, 9);
    let num4 = getRandomInt(1, 9);
    let op1 = operations[Math.floor(Math.random() * operations.length)];
    let op2 = operations[Math.floor(Math.random() * operations.length)];
    let op3 = operations[Math.floor(Math.random() * operations.length)];

    // Avoid division by zero and ensure positive answers
    if (op1 === '/' && num2 === 0) num2 = getRandomInt(1, 9);
    if (op2 === '/' && num3 === 0) num3 = getRandomInt(1, 9);
    if (op3 === '/' && num4 === 0) num4 = getRandomInt(1, 9);

    let expression = `${num1} ${op1} ${num2} ${op2} ${num3} ${op3} ${num4}`;
    let answer = eval(expression);

    // Adjust to prevent negative answers and invalid results
    if (answer < 0 || isNaN(answer) || !isFinite(answer)) {
      return generateHighStressProblem(); // Regenerate problem
    }

    // Round answer to 2 decimal places if necessary
    if (typeof answer === 'number') {
      answer = Math.round((answer + Number.EPSILON) * 100) / 100;
    }

    return { expression, answer };
  };

  const getRandomInt = (min, max) => {
    // Inclusive of min and max
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  const handleInputChange = (text) => {
    // Regular expression to match valid numeric input (positive integers)
    const numericRegex = /^-?\d*\.?\d*$/;

    if (numericRegex.test(text)) {
      setUserAnswer(text);
    }
  };

  const handleAnswerSubmit = async () => {
    if (userAnswer.trim() === '') {
      Alert.alert('Input Required', 'Please enter your answer.');
      return;
    }

    const correctAnswer = currentProblem.answer;
    let userAnswerNum = parseFloat(userAnswer);

    if (isNaN(userAnswerNum)) {
      Alert.alert('Invalid Input', 'Please enter a valid number.');
      return;
    }

    // Round user answer to 2 decimal places if necessary
    userAnswerNum = Math.round((userAnswerNum + Number.EPSILON) * 100) / 100;

    const isCorrect = userAnswerNum === correctAnswer;

    const endTime = new Date();
    const timeTaken = (endTime - startTime) / 1000; // Time in seconds

    const problemResult = {
      condition: conditions[conditionIndex],
      difficulty: difficulties[difficultyIndex],
      trial: trialIndex + 1,
      equation: currentProblem.expression,
      correctAnswer: correctAnswer,
      userAnswer: userAnswerNum,
      isCorrect: isCorrect,
      timeTaken: timeTaken,
    };

    setResults((prevResults) => [...prevResults, problemResult]);

    if (!isCorrect) {
      await triggerFeedback(); // Play sound and vibrate
    }

    // Move to the next equation
    setEquationIndex((prevIndex) => prevIndex + 1);
  };

  const moveToNextTrialOrDifficulty = () => {
    if (trialIndex < 4) {
      // Move to next trial
      setTrialIndex((prevTrialIndex) => prevTrialIndex + 1);
    } else if (difficultyIndex < difficulties.length - 1) {
      // Move to next difficulty level
      setDifficultyIndex((prevDifficultyIndex) => prevDifficultyIndex + 1);
      setTrialIndex(0);
    } else if (conditionIndex < conditions.length - 1) {
      // Move to next condition
      setConditionIndex((prevConditionIndex) => prevConditionIndex + 1);
      setDifficultyIndex(0);
      setTrialIndex(0);
    } else {
      // Task completed
      setStep('completion');
    }
  };

  const startTimer = () => {
    clearTimer(); // Clear any existing interval before starting a new one

    // Set time limit per problem, e.g., 10 seconds
    const timeLimit = 10;
    setTimeRemaining(timeLimit);

    const timer = setInterval(() => {
      setTimeRemaining((prevTime) => {
        if (prevTime <= 1) {
          clearInterval(timer);
          setTimerRef(null);
          handleTimeExpired();
          return 0;
        }
        return prevTime - 1;
      });
    }, 1000);

    setTimerRef(timer);
  };

  const resetTimer = () => {
    startTimer(); // startTimer() already clears the previous interval
  };

  const handleTimeExpired = async () => {
    clearTimer();

    Alert.alert('Time Up', 'You did not answer in time.');

    const correctAnswer = currentProblem.answer;

    const endTime = new Date();
    const timeTaken = (endTime - startTime) / 1000; // Time in seconds

    const problemResult = {
      condition: conditions[conditionIndex],
      difficulty: difficulties[difficultyIndex],
      trial: trialIndex + 1,
      equation: currentProblem.expression,
      correctAnswer: correctAnswer,
      userAnswer: null,
      isCorrect: false,
      timeTaken: timeTaken,
    };

    setResults((prevResults) => [...prevResults, problemResult]);

    await triggerFeedback(); // Play sound and vibrate

    // Move to the next equation
    setEquationIndex((prevIndex) => prevIndex + 1);
  };

  const triggerFeedback = async () => {
    // Vibrate the device
    Vibration.vibrate(500); // Vibrate for 500 milliseconds

    // Play a sound
    const { sound } = await Audio.Sound.createAsync(
      require('../assets/negative_feedback.mp3') // Replace with the correct path to your sound file
    );
    setSound(sound);
    await sound.playAsync();
  };

  const handleStartTask = () => {
    setTaskStartTime(new Date()); // Record the start time of the task
    setStep('task');
  };

  const handleFinish = () => {
    setStep('questionnaire');
  };

  // New function to submit the questionnaire data
  const submitQuestionnaire = async () => {
    if (stressResponse === null) {
      Alert.alert('Input Required', 'Please select your stress level.');
      return;
    }

    // Prepare the data to be sent
    const data = {
      startTime: taskStartTime,
      results: results,
      stressResponse: stressResponse,
    };
    console.log(data)
    try {
      // Replace 'your_api_endpoint' with the actual API endpoint
      const response = await fetch('your_api_endpoint', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (response.ok) {
        Alert.alert('Thank you', 'Your responses have been submitted.');
        // Reset the app or navigate to another screen as needed
        setStep('introduction');
        setConditionIndex(0);
        setDifficultyIndex(0);
        setTrialIndex(0);
        setEquationIndex(0);
        setProblems([]);
        setResults([]);
        setStressResponse(null);
        setTaskStartTime(null);
      } else {
        Alert.alert('Submission Failed', 'Please try again later.');
      }
    } catch (error) {
      console.error(error);
      Alert.alert('An error occurred', 'Please try again later.');
    }
  };

  return (
    <View style={styles.container}>
      {step === 'introduction' && (
        <View style={styles.content}>
          <Text style={styles.title}>MIST Task (Mental Arithmetic)</Text>
          <Text style={styles.description}>
            You will be presented with arithmetic problems of varying difficulties. Solve each as
            quickly and accurately as possible without using a calculator.
          </Text>
          <TouchableOpacity style={styles.button} onPress={handleStartTask}>
            <Text style={styles.buttonText}>Start Task</Text>
          </TouchableOpacity>
        </View>
      )}

      {step === 'task' && currentProblem && (
        <KeyboardAvoidingView
          style={styles.content}
          behavior={Platform.OS === 'ios' ? 'padding' : undefined}
        >
          <Text style={styles.conditionText}>
            Condition:{' '}
            {conditions[conditionIndex] === 'withoutTimeConstraints'
              ? 'No Time Constraints'
              : 'Time Constraints'}
          </Text>
          <Text style={styles.difficultyText}>
            Difficulty Level:{' '}
            {difficulties[difficultyIndex].charAt(0).toUpperCase() +
              difficulties[difficultyIndex].slice(1)}
          </Text>
          <Text style={styles.trialText}>Trial {trialIndex + 1} of 5</Text>
          <Text style={styles.problemText}>{currentProblem.expression}</Text>
          <TextInput
            style={styles.input}
            placeholder="Your Answer"
            keyboardType="numeric"
            autoCorrect={false}
            autoCapitalize="none"
            value={userAnswer}
            onChangeText={handleInputChange}
          />
          <TouchableOpacity style={styles.button} onPress={handleAnswerSubmit}>
            <Text style={styles.buttonText}>Submit Answer</Text>
          </TouchableOpacity>
          <Text style={styles.progressText}>
            Problem {equationIndex + 1} of {problems.length}
          </Text>
          {conditions[conditionIndex] === 'withTimeConstraints' && (
            <Text style={styles.timerText}>Time Remaining: {timeRemaining} seconds</Text>
          )}
        </KeyboardAvoidingView>
      )}

      {step === 'completion' && (
        <View style={styles.content}>
          <Text style={styles.title}>Task Complete</Text>
          <Text style={styles.description}>Thank you for completing the task.</Text>
          <TouchableOpacity style={styles.button} onPress={handleFinish}>
            <Text style={styles.buttonText}>Proceed to Questionnaire</Text>
          </TouchableOpacity>
        </View>
      )}

      {step === 'questionnaire' && (
        <View style={styles.content}>
          <Text style={styles.title}>Self-Report Measure</Text>
          <Text style={styles.description}>Please indicate your current level of stress:</Text>
          <View style={styles.stressLevelContainer}>
            {[1, 2, 3, 4, 5].map((level) => (
              <TouchableOpacity
                key={level}
                style={[
                  styles.stressLevelButton,
                  stressResponse === level && styles.stressLevelButtonSelected,
                ]}
                onPress={() => setStressResponse(level)}
              >
                <Text style={styles.stressLevelText}>{level}</Text>
              </TouchableOpacity>
            ))}
          </View>
          <TouchableOpacity style={styles.button} onPress={submitQuestionnaire}>
            <Text style={styles.buttonText}>Submit Questionnaire</Text>
          </TouchableOpacity>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  // Container styles
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  content: {
    flex: 1,
    paddingVertical: 20,
    alignItems: 'center', // Center horizontally
    paddingHorizontal: 20,
    // justifyContent: 'center', // Center vertically
  },
  // Text styles
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
    textAlign: 'center',
    marginBottom: 20,
  },
  description: {
    fontSize: 18,
    color: '#555',
    textAlign: 'center',
    marginBottom: 30,
  },
  conditionText: {
    fontSize: 20,
    color: '#333',
    textAlign: 'center',
    marginBottom: 10,
  },
  difficultyText: {
    fontSize: 20,
    color: '#333',
    textAlign: 'center',
    marginBottom: 10,
  },
  trialText: {
    fontSize: 18,
    color: '#555',
    textAlign: 'center',
    marginBottom: 10,
  },
  problemText: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#333',
    textAlign: 'center',
    marginBottom: 30,
  },
  input: {
    width: SCREEN_WIDTH * 0.8,
    height: 50,
    borderColor: '#333',
    borderWidth: 1,
    borderRadius: 5,
    paddingHorizontal: 15,
    fontSize: 18,
    marginBottom: 20,
    backgroundColor: '#fff',
  },
  progressText: {
    fontSize: 16,
    color: '#777',
    textAlign: 'center',
    marginTop: 20,
  },
  timerText: {
    fontSize: 18,
    color: '#ff0000',
    textAlign: 'center',
    marginTop: 10,
  },
  // Styles for the stress level buttons
  stressLevelContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginVertical: 20,
  },
  stressLevelButton: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: '#ccc',
    justifyContent: 'center',
    alignItems: 'center',
  },
  stressLevelButtonSelected: {
    backgroundColor: '#4682B4',
  },
  stressLevelText: {
    fontSize: 18,
    color: '#fff',
  },
  // Button styles
  button: {
    backgroundColor: '#4682B4',
    paddingVertical: 15,
    paddingHorizontal: 30,
    borderRadius: 5,
    marginTop: 20,
  },
  buttonText: {
    color: '#fff',
    fontSize: 20,
    fontWeight: 'bold',
  },
});

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/_layout.tsx
================================================================================
// app/_layout.tsx
import { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { useFonts } from 'expo-font';
import { Stack } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { StatusBar } from 'expo-status-bar';
import { useEffect } from 'react';
import 'react-native-reanimated';

import { useColorScheme } from '@/hooks/useColorScheme';
import { BLEProvider } from './services/bleServices'; // Import BLEProvider

// Prevent the splash screen from auto-hiding before asset loading is complete.
SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const colorScheme = useColorScheme();
  const [loaded] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  useEffect(() => {
    if (loaded) {
      SplashScreen.hideAsync();
    }
  }, [loaded]);

  if (!loaded) {
    return null;
  }

  return (
    <BLEProvider>
      <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
        <Stack>
          <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
          <Stack.Screen name="+not-found" />
        </Stack>
        <StatusBar style="auto" />
      </ThemeProvider>
    </BLEProvider>
  );
}

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/motor-imagery.js
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Dimensions, Alert, Image } from 'react-native';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

export default function MotorImageryScreen() {
  const [step, setStep] = useState('introduction'); // Updated steps
  const [cycleTimeLeft, setCycleTimeLeft] = useState(5); // Time left in the current squeeze/release cycle
  const [totalTimeLeft, setTotalTimeLeft] = useState(60); // Total time left for the squeezing/releasing cycles
  const [isSqueezing, setIsSqueezing] = useState(true); // Indicates whether the participant should be squeezing or releasing

  const cycleTimerRef = useRef(null);
  const totalTimerRef = useRef(null);

  // Start the squeezing/releasing cycles
  useEffect(() => {
    if (step === 'physical_squeezing' || step === 'imagery_squeezing') {
      let totalTime = step === 'physical_squeezing' ? 60 : 300; // 1 minute for physical, 5 minutes for imagery
      setTotalTimeLeft(totalTime);
      setCycleTimeLeft(5);
      setIsSqueezing(true);

      // Start total timer
      totalTimerRef.current = setInterval(() => {
        setTotalTimeLeft((prevTime) => {
          if (prevTime <= 1) {
            clearInterval(totalTimerRef.current);
            clearInterval(cycleTimerRef.current);
            if (step === 'physical_squeezing') {
              setStep('ball_taken');
            } else {
              setStep('completion');
            }
            return 0;
          }
          return prevTime - 1;
        });
      }, 1000);

      // Start cycle timer
      cycleTimerRef.current = setInterval(() => {
        setCycleTimeLeft((prevTime) => {
          if (prevTime <= 1) {
            setIsSqueezing((prev) => !prev); // Toggle between squeezing and releasing
            return 5; // Reset cycle time
          }
          return prevTime - 1;
        });
      }, 1000);

      // Cleanup on unmount or when step changes
      return () => {
        clearInterval(totalTimerRef.current);
        clearInterval(cycleTimerRef.current);
      };
    }
  }, [step]);

  const handleNextStep = async () => {
    switch (step) {
      case 'introduction':
        // Upon clicking 'Begin', send the JSON to the dummy API
        const data = {
          ambulatoryUUID: 'dummy',
          paradigm: 'MotorImagery',
          time: new Date().toISOString(),
        };

        try {
          const response = await fetch('http://localhost:3000/submit', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
          });

          if (response.ok) {
            console.log('Data submitted successfully');
            // Proceed to the next step
            setStep('relaxation');
          } else {
            console.error('Error submitting data');
            Alert.alert('Error', 'There was a problem submitting your data.');
          }
        } catch (error) {
          console.error('Network error:', error);
          Alert.alert('Error', 'Network error occurred while submitting your data.');
          setStep('relaxation');
        }
        break;

      case 'relaxation':
        setStep('preparation');
        break;
      case 'preparation':
        setStep('physical_squeezing');
        break;
      case 'ball_taken':
        setStep('imagery_introduction');
        break;
      case 'imagery_introduction':
        setStep('imagery_squeezing');
        break;
      case 'completion':
        // Navigate back or provide additional options
        Alert.alert('Task Completed', 'Thank you for participating in the motor imagery task.');
        break;
      default:
        break;
    }
  };

  return (
    <View style={styles.container}>
      {step === 'introduction' && (
        <View style={styles.content}>
          <Text style={styles.title}>Motor Imagery Task</Text>
          <Text style={styles.description}>
            In this task, you'll perform a motor imagery exercise using a stress ball.
            We'll guide you through the steps.
          </Text>
          <TouchableOpacity style={styles.button} onPress={handleNextStep}>
            <Text style={styles.buttonText}>Begin</Text>
          </TouchableOpacity>
        </View>
      )}

      {step === 'relaxation' && (
        <View style={styles.content}>
          <Text style={styles.title}>Relaxation Exercise</Text>
          <Text style={styles.description}>
            Take a moment to relax. Close your eyes and take a few deep breaths.
          </Text>
          <TouchableOpacity style={styles.button} onPress={handleNextStep}>
            <Text style={styles.buttonText}>I'm Ready</Text>
          </TouchableOpacity>
        </View>
      )}

      {step === 'preparation' && (
        <View style={styles.content}>
          <Text style={styles.title}>Get Your Stress Ball</Text>
          <Text style={styles.description}>
            Please hold the stress ball in your hand.
          </Text>
          <TouchableOpacity style={styles.button} onPress={handleNextStep}>
            <Text style={styles.buttonText}>Start Exercise</Text>
          </TouchableOpacity>
        </View>
      )}

      {step === 'physical_squeezing' && (
        <View style={styles.content}>
          <Text style={styles.title}>
            {isSqueezing ? 'Squeeze the Stress Ball' : 'Release the Tension'}
          </Text>
          <Text style={styles.timer}>
            {cycleTimeLeft} second{cycleTimeLeft !== 1 ? 's' : ''} left
          </Text>
          <Text style={styles.totalTimer}>
            Total Time Left: {totalTimeLeft} second{totalTimeLeft !== 1 ? 's' : ''}
          </Text>
        </View>
      )}

      {step === 'ball_taken' && (
        <View style={styles.content}>
          <Text style={styles.title}>Set the Stress Ball Aside</Text>
          <Text style={styles.description}>
            Please set the stress ball aside. We will now proceed to the next part of the exercise.
          </Text>
          <TouchableOpacity style={styles.button} onPress={handleNextStep}>
            <Text style={styles.buttonText}>Continue</Text>
          </TouchableOpacity>
        </View>
      )}

      {step === 'imagery_introduction' && (
        <View style={styles.content}>
          <Text style={styles.title}>Motor Imagery Exercise</Text>
          <Text style={styles.description}>
            Now, imagine holding a stress ball in your hand. Visualize it as clearly as possible.
          </Text>
          {/* Visual cue, e.g., an image or animation */}
          {/* Replace with your own image or animation */}
          <View style={styles.imagePlaceholder}>
            <Text>Stress Ball Image</Text>
          </View>
          <TouchableOpacity style={styles.button} onPress={handleNextStep}>
            <Text style={styles.buttonText}>Start Imagery Exercise</Text>
          </TouchableOpacity>
        </View>
      )}

      {step === 'imagery_squeezing' && (
        <View style={styles.content}>
          <Text style={styles.title}>
            {isSqueezing ? 'Imagine Squeezing the Stress Ball' : 'Imagine Releasing the Tension'}
          </Text>
          <Text style={styles.timer}>
            {cycleTimeLeft} second{cycleTimeLeft !== 1 ? 's' : ''} left
          </Text>
          <Text style={styles.totalTimer}>
            Total Time Left: {totalTimeLeft} second{totalTimeLeft !== 1 ? 's' : ''}
          </Text>
          {/* Visual cue, e.g., an image or animation */}
          {/* Replace with your own image or animation */}
          <View style={styles.imagePlaceholder}>
            <Text>Stress Ball Image</Text>
          </View>
          {/* Optional guidance or reminders */}
          <Text style={styles.description}>
            Keep focusing on the sensation of squeezing and releasing the stress ball in your mind.
          </Text>
        </View>
      )}

      {step === 'completion' && (
        <View style={styles.content}>
          <Text style={styles.title}>Task Complete</Text>
          <Text style={styles.description}>
            Thank you for completing the motor imagery task.
          </Text>
          <TouchableOpacity style={styles.button} onPress={handleNextStep}>
            <Text style={styles.buttonText}>Finish</Text>
          </TouchableOpacity>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  // Container styles
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  content: {
    flex: 1,
    paddingVertical: 20,
    alignItems: 'center', // Center horizontally
    paddingHorizontal: 20,
    marginTop: 50,
  },
  // Text styles
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
    textAlign: 'center',
    marginBottom: 20,
  },
  description: {
    fontSize: 18,
    color: '#555',
    textAlign: 'center',
    marginBottom: 30,
  },
  timer: {
    fontSize: 36,
    fontWeight: 'bold',
    color: '#333',
    textAlign: 'center',
    marginBottom: 20,
  },
  totalTimer: {
    fontSize: 18,
    color: '#777',
    textAlign: 'center',
  },
  // Image placeholder styles
  imagePlaceholder: {
    width: 200,
    height: 200,
    backgroundColor: '#ddd',
    justifyContent: 'center',
    alignItems: 'center',
    marginVertical: 20,
  },
  // Button styles
  button: {
    backgroundColor: '#4682B4',
    paddingVertical: 15,
    paddingHorizontal: 30,
    borderRadius: 5,
    marginTop: 30,
  },
  buttonText: {
    color: '#fff',
    fontSize: 20,
    fontWeight: 'bold',
  },
});

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/mental-relaxation.js
================================================================================
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Dimensions,
  Alert,
  ScrollView,
  Animated,
} from 'react-native';
import { useNavigation } from 'expo-router';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

export default function MentalRelaxationScreen() {
  const [step, setStep] = useState('introduction'); // 'introduction', 'meditation', 'questionnaire', 'completed'
  const [meditationTimeLeft, setMeditationTimeLeft] = useState(600); // 10 minutes in seconds
  const [currentInstructionIndex, setCurrentInstructionIndex] = useState(0);
  const [responses, setResponses] = useState({
    stressLevel: null,
    relaxationLevel: null,
  });
  const [progress, setProgress] = useState(new Animated.Value(0));
  const navigation = useNavigation();

  const instructions = [
    { time: 0, text: 'Welcome to the guided meditation session.' },
    { time: 10, text: 'Find a comfortable seated position and close your eyes for 20 seconds. Then open your eyes' },
    { time: 30, text: 'Take a deep breath in... and out.' },
    { time: 60, text: 'Focus on your breathing, feeling the air enter and leave your body.' },
    { time: 90, text: 'Gently tense and relax your muscles starting from your toes to your head.' },
    { time: 180, text: 'Visualize a calming scene, like a peaceful beach or a quiet forest.' },
    { time: 300, text: 'Continue to breathe deeply and let go of any tension.' },
    { time: 480, text: 'You are relaxed and at peace.' },
    { time: 540, text: 'Begin to bring your awareness back to the present moment.' },
    { time: 570, text: 'Gently wiggle your fingers and toes.' },
    { time: 590, text: 'When you are ready, slowly open your eyes.' },
    { time: 600, text: 'Meditation complete. Thank you for participating.' },
  ];

  useEffect(() => {
    if (step === 'meditation') {
      const timer = setInterval(() => {
        setMeditationTimeLeft((prevTime) => {
          if (prevTime <= 1) {
            clearInterval(timer);
            setStep('questionnaire');
            return 0;
          }
          return prevTime - 1;
        });
      }, 1000);

      return () => clearInterval(timer);
    }
  }, [step]);

  useEffect(() => {
    if (step === 'meditation') {
      // Update the current instruction based on the time elapsed
      const elapsed = 600 - meditationTimeLeft;
      const nextInstructionIndex = instructions.findIndex(
        (instruction, index) =>
          elapsed >= instruction.time &&
          (instructions[index + 1] ? elapsed < instructions[index + 1].time : true)
      );
      setCurrentInstructionIndex(nextInstructionIndex);

      // Update progress bar
      Animated.timing(progress, {
        toValue: (elapsed / 600) * 100,
        duration: 500,
        useNativeDriver: false,
      }).start();
    }
  }, [meditationTimeLeft]);

  const handleStartMeditation = () => {
    setStep('meditation');
  };

  const handleResponseChange = (key, value) => {
    setResponses((prevResponses) => ({
      ...prevResponses,
      [key]: value,
    }));
  };

  const handleSubmit = async () => {
    const data = {
      paradigm: 'MentalRelaxation',
      ambulatoryUUID: 'dummy',
      time: new Date().toISOString(),
      responses,
    };

    try {
      const response = await fetch('http://localhost:3000/submit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (response.ok) {
        // Handle successful response
        console.log('Data submitted successfully');
        Alert.alert('Success', 'Your responses have been submitted.');
        setStep('completed');
      } else {
        // Handle error response
        console.error('Error submitting data');
        Alert.alert('Error', 'There was a problem submitting your responses.');
      }
    } catch (error) {
      console.error('Network error:', error);
      Alert.alert('Error', 'Network error occurred while submitting your responses.');
    }
  };

  const isFormComplete = Object.values(responses).every((value) => value !== null);

  return (
    <View style={styles.container}>
      {step === 'introduction' && (
        <View style={styles.content}>
          <Text style={styles.title}>Guided Meditation</Text>
          <Text style={styles.instructionText}>
            This meditation will guide you through relaxation techniques over the next 10 minutes.
          </Text>
          <TouchableOpacity style={styles.startButton} onPress={handleStartMeditation}>
            <Text style={styles.startButtonText}>Start Meditation</Text>
          </TouchableOpacity>
        </View>
      )}

      {step === 'meditation' && (
        <View style={styles.content}>
          <Text style={styles.instructionText}>
            {instructions[currentInstructionIndex]?.text}
          </Text>
          <View style={styles.progressBarContainer}>
            <View style={styles.progressBarBackground}>
              <Animated.View
                style={[
                  styles.progressBarFill,
                  { width: progress.interpolate({ inputRange: [0, 100], outputRange: ['0%', '100%'] }) },
                ]}
              />
            </View>
            <Text style={styles.timeLeftText}>
              Time Left: {Math.floor(meditationTimeLeft / 60)}:
              {String(meditationTimeLeft % 60).padStart(2, '0')}
            </Text>
          </View>
        </View>
      )}

      {step === 'questionnaire' && (
        <ScrollView contentContainerStyle={styles.content} showsVerticalScrollIndicator={false}>
          <Text style={styles.title}>Post-Meditation Questionnaire</Text>
          <View style={styles.questionContainer}>
            <Text style={styles.questionText}>How stressed do you feel right now?</Text>
            <View style={styles.ratingContainer}>
              {[0, 1, 2, 3, 4, 5].map((value) => (
                <TouchableOpacity
                  key={value}
                  style={styles.ratingCircle}
                  onPress={() => handleResponseChange('stressLevel', value)}
                >
                  <Text
                    style={[
                      styles.ratingNumber,
                      responses.stressLevel === value && styles.selectedRating,
                    ]}
                  >
                    {value}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>

          <View style={styles.questionContainer}>
            <Text style={styles.questionText}>How relaxed do you feel right now?</Text>
            <View style={styles.ratingContainer}>
              {[0, 1, 2, 3, 4, 5].map((value) => (
                <TouchableOpacity
                  key={value}
                  style={styles.ratingCircle}
                  onPress={() => handleResponseChange('relaxationLevel', value)}
                >
                  <Text
                    style={[
                      styles.ratingNumber,
                      responses.relaxationLevel === value && styles.selectedRating,
                    ]}
                  >
                    {value}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>

          {/* Submit Button */}
          <TouchableOpacity
            style={[styles.submitButton, !isFormComplete && styles.disabledButton]}
            onPress={handleSubmit}
            disabled={!isFormComplete}
          >
            <Text style={styles.submitButtonText}>Submit</Text>
          </TouchableOpacity>
        </ScrollView>
      )}

      {step === 'completed' && (
        <View style={styles.content}>
          <Text style={styles.title}>Thank You!</Text>
          <Text style={styles.instructionText}>
            Your responses have been recorded. You may now return to the main menu.
          </Text>
          <TouchableOpacity
            style={styles.startButton}
            onPress={() => navigation.navigate('ParadigmSelectionScreen')}
          >
            <Text style={styles.startButtonText}>Back to Menu</Text>
          </TouchableOpacity>
        </View>
      )}
    </View>
  );
}
const styles = StyleSheet.create({
  // Container styles
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  content: {
    flex: 1,
    paddingVertical: 40,
    paddingHorizontal: 20,
    alignItems: 'center',
    // justifyContent: 'center',
    marginTop:60,
  },
  // Text styles
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
    textAlign: 'center',
    marginBottom: 30,
  },
  instructionText: {
    fontSize: 20,
    color: '#333',
    textAlign: 'center',
    marginBottom: 40,
  },
  // Start button styles
  startButton: {
    backgroundColor: '#4682B4',
    paddingVertical: 15,
    paddingHorizontal: 40,
    borderRadius: 5,
  },
  startButtonText: {
    color: '#fff',
    fontSize: 20,
    fontWeight: 'bold',
  },
  // Progress bar styles
  progressBarContainer: {
    width: '100%',
    alignItems: 'center',
  },
  progressBarBackground: {
    width: '100%',
    height: 20,
    backgroundColor: '#d3d3d3',
    borderRadius: 10,
    overflow: 'hidden',
    marginBottom: 10,
  },
  progressBarFill: {
    height: '100%',
    backgroundColor: '#4682B4',
  },
  timeLeftText: {
    fontSize: 16,
    color: '#333',
  },
  // Questionnaire styles
  questionContainer: {
    marginBottom: 40,
    width: '100%',
    alignItems: 'center',
  },
  questionText: {
    fontSize: 20,
    color: '#333',
    textAlign: 'center',
    marginBottom: 20,
  },
  ratingContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: SCREEN_WIDTH * 0.8,
  },
  ratingCircle: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: '#d3d3d3',
    // justifyContent: 'center',
    marginTop: 60,
    alignItems: 'center',
  },
  ratingNumber: {
    fontSize: 18,
    color: '#333',
  },
  selectedRating: {
    fontWeight: 'bold',
    color: '#4682B4',
  },
  // Submit button styles
  submitButton: {
    backgroundColor: '#4682B4',
    paddingVertical: 15,
    paddingHorizontal: 30,
    borderRadius: 5,
    marginTop: 20,
    marginBottom: 40,
  },
  disabledButton: {
    backgroundColor: '#A9A9A9', // Gray color to indicate disabled state
  },
  submitButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
    textAlign: 'center',
  },
});

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/ema-questionnaire.js
================================================================================
import React, { useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Dimensions, Alert, ScrollView } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

export default function EMAQuestionnaireScreen() {
  const [responses, setResponses] = useState({
    stressLevel: null,
    mood: null,
    energy: null,
    independence: null,
  });

  const questions = [
    {
      key: 'stressLevel',
      question: 'How stressed are you feeling today?',
      icons: [
        { level: 0, icon: 'emoticon-excited-outline', color: '#4CAF50' },
        { level: 1, icon: 'emoticon-happy-outline', color: '#8BC34A' },
        { level: 2, icon: 'emoticon-neutral-outline', color: '#FFEB3B' },
        { level: 3, icon: 'emoticon-sad-outline', color: '#FFC107' },
        { level: 4, icon: 'emoticon-dead-outline', color: '#FF9800' },
        { level: 5, icon: 'emoticon-angry-outline', color: '#F44336' },
      ],
    },
    {
      key: 'mood',
      question: 'How do you feel today? (Sad to Cheerful)',
      icons: [
        { level: 0, icon: 'emoticon-cry-outline', color: '#2196F3' },
        { level: 1, icon: 'emoticon-frown-outline', color: '#42A5F5' },
        { level: 2, icon: 'emoticon-neutral-outline', color: '#64B5F6' },
        { level: 3, icon: 'emoticon-happy-outline', color: '#90CAF9' },
        { level: 4, icon: 'emoticon-excited-outline', color: '#BBDEFB' },
        { level: 5, icon: 'emoticon-cool-outline', color: '#E3F2FD' },
      ],
    },
    {
      key: 'energy',
      question: 'How energetic do you feel? (Quiet to Active)',
      icons: [
        { level: 0, icon: 'weather-night', color: '#9C27B0' },
        { level: 1, icon: 'weather-sunset-down', color: '#AB47BC' },
        { level: 2, icon: 'weather-cloudy', color: '#BA68C8' },
        { level: 3, icon: 'weather-sunset', color: '#CE93D8' },
        { level: 4, icon: 'weather-sunny', color: '#E1BEE7' },
        { level: 5, icon: 'white-balance-sunny', color: '#F3E5F5' },
      ],
    },
    {
      key: 'independence',
      question: 'How independent do you feel? (Dependent to Independent)',
      icons: [
        { level: 0, icon: 'account-child-outline', color: '#FF5722' },
        { level: 1, icon: 'account-supervisor-outline', color: '#FF7043' },
        { level: 2, icon: 'account-outline', color: '#FF8A65' },
        { level: 3, icon: 'account', color: '#FFAB91' },
        { level: 4, icon: 'account-star-outline', color: '#FFCCBC' },
        { level: 5, icon: 'account-tie-outline', color: '#FBE9E7' },
      ],
    },
  ];

  const handleRatingPress = (questionKey, rating) => {
    setResponses((prevResponses) => ({
      ...prevResponses,
      [questionKey]: rating,
    }));
  };

  const handleSubmit = async () => {
    const data = {
      paradigm: 'EMAQuestion',
      ambulatoryUUID: 'dummy',
      time: new Date().toISOString(),
      responses,
    };
    console.log(data)

    try {
      const response = await fetch('http://localhost:3000/submit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (response.ok) {
        // Handle successful response
        console.log('Data submitted successfully');
        Alert.alert('Success', 'Your responses have been submitted.');
      } else {
        // Handle error response
        console.error('Error submitting data');
        Alert.alert('Error', 'There was a problem submitting your responses.');
      }
    } catch (error) {
      console.error('Network error:', error);
      Alert.alert('Error', 'Network error occurred while submitting your responses.');
    }
  };

  const isFormComplete = Object.values(responses).every((value) => value !== null);

  return (
    <View style={styles.container}>
      <ScrollView contentContainerStyle={styles.content} showsVerticalScrollIndicator={false}>
        {questions.map((question) => (
          <View key={question.key} style={styles.questionContainer}>
            <Text style={styles.title}>{question.question}</Text>
            <View style={styles.ratingContainer}>
              {question.icons.map((item) => (
                <TouchableOpacity
                  key={item.level}
                  style={styles.iconContainer}
                  onPress={() => handleRatingPress(question.key, item.level)}
                >
                  <MaterialCommunityIcons
                    name={item.icon}
                    size={50}
                    color={responses[question.key] === item.level ? item.color : '#d3d3d3'}
                  />
                  <Text style={styles.ratingLabel}>{item.level}</Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>
        ))}

        {/* Submit Button */}
        <TouchableOpacity
          style={[styles.submitButton, !isFormComplete && styles.disabledButton]}
          onPress={handleSubmit}
          disabled={!isFormComplete}
        >
          <Text style={styles.submitButtonText}>Submit</Text>
        </TouchableOpacity>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  // Container styles
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  content: {
    paddingVertical: 20,
    alignItems: 'center', // Center horizontally
    paddingHorizontal: 20,
  },
  // Question container
  questionContainer: {
    marginBottom: 40,
    width: '100%',
    alignItems: 'center',
  },
  // Text styles
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    textAlign: 'center',
    marginBottom: 20,
  },
  // Rating styles
  ratingContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: SCREEN_WIDTH * 0.9,
  },
  iconContainer: {
    alignItems: 'center',
  },
  ratingLabel: {
    marginTop: 5,
    fontSize: 14,
    color: '#333',
  },
  // Submit button styles
  submitButton: {
    backgroundColor: '#4682B4',
    paddingVertical: 15,
    paddingHorizontal: 30,
    borderRadius: 5,
    marginTop: 20,
    marginBottom: 40,
  },
  disabledButton: {
    backgroundColor: '#A9A9A9', // Gray color to indicate disabled state
  },
  submitButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
    textAlign: 'center',
  },
});

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/constants/index.js
================================================================================
// app/constants/index.js

export * from './api';
export * from './ble';
// Export other constant files as needed

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/constants/ble.js
================================================================================
// app/constants/ble.js

export const BLE_SERVICES = {
    BATTERY_SERVICE: '0000180F-0000-1000-8000-00805f9b34fb', // Standard Battery Service UUID
    // Add other service UUIDs as needed
  };
  
  export const BLE_CHARACTERISTICS = {
    BATTERY_LEVEL: '00002A19-0000-1000-8000-00805f9b34fb', // Standard Battery Level Characteristic UUID
    NOTIFICATION_CHARACTERISTIC_1: '0000yyyy-0000-1000-8000-00805f9b34fb',
    NOTIFICATION_CHARACTERISTIC_2: '0000zzzz-0000-1000-8000-00805f9b34fb',
    // Add more characteristic UUIDs as needed
  };
  
  // If you have multiple notification characteristics, list them in an array
  export const BLE_NOTIFICATION_CHARACTERISTICS = [
    BLE_CHARACTERISTICS.NOTIFICATION_CHARACTERISTIC_1,
    BLE_CHARACTERISTICS.NOTIFICATION_CHARACTERISTIC_2,
    // Add more as needed
  ];
  
================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/constants/api.js
================================================================================
// app/constants/api.js

const API_BASE_URL = 'http://localhost:3000'; // Replace with your actual base URL

export const API_ENDPOINTS = {
  SUBMIT_DATA: `${API_BASE_URL}/submit`,
  // Add more endpoints as needed
};

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/(tabs)/ParadigmSelectionScreen.js
================================================================================
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, ScrollView, Dimensions } from 'react-native';
import { useRouter } from 'expo-router';

const SCREEN_HEIGHT = Dimensions.get('window').height;
const SCREEN_WIDTH = Dimensions.get('window').width;

// List of selections remains the same
const selections = [
  { id: '1', title: 'MIST question', route: 'mist-question' },
  { id: '2', title: 'Fear conditioning', route: 'fear-conditioning' },
  { id: '3', title: 'Mental relaxation', route: 'mental-relaxation' },
  { id: '4', title: 'Motor imagery', route: 'motor-imagery' },
  { id: '5', title: 'Auditory oddball', route: 'auditory-oddball' },
  { id: '6', title: 'EMA', route: 'ema-questionnaire'},
];

export default function ParadigmSelectionScreen() {
  const router = useRouter();

  return (
    <View style={styles.container}>
      <ScrollView contentContainerStyle={styles.listContainer}>
        {selections.map((item) => (
          <TouchableOpacity
            key={item.id}
            style={styles.selectionButton}
            onPress={() => router.push(item.route)} // Navigate to the appropriate route
          >
            <Text style={styles.selectionText}>{item.title}</Text>
          </TouchableOpacity>
        ))}
      </ScrollView>
    </View>
  );
}

// Styles remain the same as updated earlier
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#d3d3d3',
    paddingTop:50,
    paddingBottom:70,
  },
  listContainer: {
    paddingVertical: 20,
  },
  selectionButton: {
    height: SCREEN_HEIGHT / 7,
    width: SCREEN_WIDTH * 0.9,
    backgroundColor: '#4682B4',
    marginVertical: 10,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 5,
    alignSelf: 'center', // Center the buttons horizontally
  },
  selectionText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#fff',
    textAlign: 'center',
  },
});

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/(tabs)/index.tsx
================================================================================
import { Image, StyleSheet, Platform } from 'react-native';

import { HelloWave } from '@/components/HelloWave';
import ParallaxScrollView from '@/components/ParallaxScrollView';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';

export default function HomeScreen() {
  return (
    <ParallaxScrollView
      headerBackgroundColor={{ light: '#A1CEDC', dark: '#1D3D47' }}
      headerImage={
        <Image
          source={require('@/assets/images/partial-react-logo.png')}
          style={styles.reactLogo}
        />
      }>
      <ThemedView style={styles.titleContainer}>
        <ThemedText type="title">Welcome!</ThemedText>
        <HelloWave />
      </ThemedView>
      <ThemedView style={styles.stepContainer}>
        <ThemedText type="subtitle">Step 1: Try it</ThemedText>
        <ThemedText>
          Edit <ThemedText type="defaultSemiBold">app/(tabs)/index.tsx</ThemedText> to see changes.
          Press{' '}
          <ThemedText type="defaultSemiBold">
            {Platform.select({
              ios: 'cmd + d',
              android: 'cmd + m',
              web: 'F12'
            })}
          </ThemedText>{' '}
          to open developer tools.
        </ThemedText>
      </ThemedView>
      <ThemedView style={styles.stepContainer}>
        <ThemedText type="subtitle">Step 2: Explore</ThemedText>
        <ThemedText>
          Tap the Explore tab to learn more about what's included in this starter app.
        </ThemedText>
      </ThemedView>
      <ThemedView style={styles.stepContainer}>
        <ThemedText type="subtitle">Step 3: Get a fresh start</ThemedText>
        <ThemedText>
          When you're ready, run{' '}
          <ThemedText type="defaultSemiBold">npm run reset-project</ThemedText> to get a fresh{' '}
          <ThemedText type="defaultSemiBold">app</ThemedText> directory. This will move the current{' '}
          <ThemedText type="defaultSemiBold">app</ThemedText> to{' '}
          <ThemedText type="defaultSemiBold">app-example</ThemedText>.
        </ThemedText>
      </ThemedView>
    </ParallaxScrollView>
  );
}

const styles = StyleSheet.create({
  titleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  stepContainer: {
    gap: 8,
    marginBottom: 8,
  },
  reactLogo: {
    height: 178,
    width: 290,
    bottom: 0,
    left: 0,
    position: 'absolute',
  },
});

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/(tabs)/devices.tsx
================================================================================
// app/(tabs)/devices.tsx
import React, { useState } from 'react';
import { StyleSheet, TouchableOpacity, FlatList, Modal, Text } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import DeviceCard from '../components/DeviceCard';
import AddDeviceModal from '../components/AddDeviceModal';
import { useBLE } from '../services/bleServices';

export default function DevicesScreen() {
  const [modalVisible, setModalVisible] = useState(false);
  const { connectedDevices } = useBLE(); // Custom hook to manage BLE devices

  const handleAddDevice = () => {
    setModalVisible(true);
  };

  // Append an "Add Device" placeholder to the connected devices list
  const dataWithAddPlaceholder = [
    ...connectedDevices,
    { id: 'add_placeholder', isAddPlaceholder: true },
  ];

  const renderItem = ({ item }) => {
    if (item.isAddPlaceholder) {
      return (
        <TouchableOpacity style={styles.addCard} onPress={handleAddDevice}>
          <MaterialCommunityIcons name="plus" size={30} color="#fff" />
          <Text style={styles.addCardText}>Add Device</Text>
        </TouchableOpacity>
      );
    } else {
      return <DeviceCard device={item} />;
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      {/* Device List with Add Device Placeholder */}
      <FlatList
        data={dataWithAddPlaceholder}
        keyExtractor={(item) => item.id}
        renderItem={renderItem}
        contentContainerStyle={styles.listContainer}
      />

      {/* Add Device Modal */}
      <Modal
        animationType="slide"
        transparent={true}
        visible={modalVisible}
        onRequestClose={() => {
          setModalVisible(false);
        }}
      >
        <AddDeviceModal onClose={() => setModalVisible(false)} />
      </Modal>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 16,
  },
  listContainer: {
    paddingBottom: 20, // Ensure content is not hidden behind the tab bar
  },
  addCard: {
    backgroundColor: '#4682B4',
    paddingVertical: 20,
    borderRadius: 10,
    marginBottom: 16,
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'column',
  },
  addCardText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
    marginTop: 10,
  },
});

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/(tabs)/_layout.tsx
================================================================================
// Add 'devices' to the selections array
import { Tabs } from 'expo-router';
import React from 'react';
import { Platform } from 'react-native';

import { HapticTab } from '@/components/HapticTab';
import { IconSymbol } from '@/components/ui/IconSymbol';
import TabBarBackground from '@/components/ui/TabBarBackground';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function TabLayout() {
  const colorScheme = useColorScheme();

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: Colors[colorScheme ?? 'light'].tint,
        headerShown: false,
        tabBarButton: HapticTab,
        tabBarBackground: TabBarBackground,
        tabBarStyle: Platform.select({
          ios: {
            // Use a transparent background on iOS to show the blur effect
            position: 'absolute',
          },
          default: {},
        }),
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="house.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="explore"
        options={{
          title: 'Explore',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="paperplane.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="ParadigmSelectionScreen"
        options={{
          title: 'Paradigm',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="list.bullet" color={color} />,
        }}
      />
      {/* Add the Devices Tab */}
      <Tabs.Screen
        name="devices"
        options={{
          title: 'Devices',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="bluetooth.connect" color={color} />,
        }}
      />
    </Tabs>
  );
}

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/(tabs)/explore.tsx
================================================================================
import { StyleSheet, Image, Platform } from 'react-native';

import { Collapsible } from '@/components/Collapsible';
import { ExternalLink } from '@/components/ExternalLink';
import ParallaxScrollView from '@/components/ParallaxScrollView';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';

export default function TabTwoScreen() {
  return (
    <ParallaxScrollView
      headerBackgroundColor={{ light: '#D0D0D0', dark: '#353636' }}
      headerImage={
        <IconSymbol
          size={310}
          color="#808080"
          name="chevron.left.forwardslash.chevron.right"
          style={styles.headerImage}
        />
      }>
      <ThemedView style={styles.titleContainer}>
        <ThemedText type="title">Explore</ThemedText>
      </ThemedView>
      <ThemedText>This app includes example code to help you get started.</ThemedText>
      <Collapsible title="File-based routing">
        <ThemedText>
          This app has two screens:{' '}
          <ThemedText type="defaultSemiBold">app/(tabs)/index.tsx</ThemedText> and{' '}
          <ThemedText type="defaultSemiBold">app/(tabs)/explore.tsx</ThemedText>
        </ThemedText>
        <ThemedText>
          The layout file in <ThemedText type="defaultSemiBold">app/(tabs)/_layout.tsx</ThemedText>{' '}
          sets up the tab navigator.
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/router/introduction">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Android, iOS, and web support">
        <ThemedText>
          You can open this project on Android, iOS, and the web. To open the web version, press{' '}
          <ThemedText type="defaultSemiBold">w</ThemedText> in the terminal running this project.
        </ThemedText>
      </Collapsible>
      <Collapsible title="Images">
        <ThemedText>
          For static images, you can use the <ThemedText type="defaultSemiBold">@2x</ThemedText> and{' '}
          <ThemedText type="defaultSemiBold">@3x</ThemedText> suffixes to provide files for
          different screen densities
        </ThemedText>
        <Image source={require('@/assets/images/react-logo.png')} style={{ alignSelf: 'center' }} />
        <ExternalLink href="https://reactnative.dev/docs/images">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Custom fonts">
        <ThemedText>
          Open <ThemedText type="defaultSemiBold">app/_layout.tsx</ThemedText> to see how to load{' '}
          <ThemedText style={{ fontFamily: 'SpaceMono' }}>
            custom fonts such as this one.
          </ThemedText>
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/versions/latest/sdk/font">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Light and dark mode components">
        <ThemedText>
          This template has light and dark mode support. The{' '}
          <ThemedText type="defaultSemiBold">useColorScheme()</ThemedText> hook lets you inspect
          what the user's current color scheme is, and so you can adjust UI colors accordingly.
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/develop/user-interface/color-themes/">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Animations">
        <ThemedText>
          This template includes an example of an animated component. The{' '}
          <ThemedText type="defaultSemiBold">components/HelloWave.tsx</ThemedText> component uses
          the powerful <ThemedText type="defaultSemiBold">react-native-reanimated</ThemedText>{' '}
          library to create a waving hand animation.
        </ThemedText>
        {Platform.select({
          ios: (
            <ThemedText>
              The <ThemedText type="defaultSemiBold">components/ParallaxScrollView.tsx</ThemedText>{' '}
              component provides a parallax effect for the header image.
            </ThemedText>
          ),
        })}
      </Collapsible>
    </ParallaxScrollView>
  );
}

const styles = StyleSheet.create({
  headerImage: {
    color: '#808080',
    bottom: -90,
    left: -35,
    position: 'absolute',
  },
  titleContainer: {
    flexDirection: 'row',
    gap: 8,
  },
});

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/utils/ImageManager.js
================================================================================
const importAll = (r) => r.keys().map(r);

const fearSet1 = importAll(require.context('../../assets/images/Fear/Set 1', false, /\.(png|jpe?g|svg)$/));
const fearSet2 = importAll(require.context('../../assets/images/Fear/Set 2', false, /\.(png|jpe?g|svg)$/));
const fearSet3 = importAll(require.context('../../assets/images/Fear/Set 3', false, /\.(png|jpe?g|svg)$/));
const fearSet4 = importAll(require.context('../../assets/images/Fear/Set 4', false, /\.(png|jpe?g|svg)$/));

const happySet1 = importAll(require.context('../../assets/images/Happy/Set 1', false, /\.(png|jpe?g|svg)$/));
const happySet2 = importAll(require.context('../../assets/images/Happy/Set 2', false, /\.(png|jpe?g|svg)$/));
const happySet3 = importAll(require.context('../../assets/images/Happy/Set 3', false, /\.(png|jpe?g|svg)$/));
const happySet4 = importAll(require.context('../../assets/images/Happy/Set 4', false, /\.(png|jpe?g|svg)$/));

const images = {
  Fear: {
    'Set 1': fearSet1,
    'Set 2': fearSet2,
    'Set 3': fearSet3,
    'Set 4': fearSet4,
  },
  Happy: {
    'Set 1': happySet1,
    'Set 2': happySet2,
    'Set 3': happySet3,
    'Set 4': happySet4,
  },
};

export default images;

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/components/DeviceCard.js
================================================================================
// app/components/DeviceCard.js
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ActivityIndicator, Alert } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useBLE } from '../services/bleServices';

export default function DeviceCard({ device }) {
  const { disconnectDevice } = useBLE(); // Access BLE actions

  const handleDisconnect = async () => {
    const success = await disconnectDevice(device.id);
    if (success) {
      Alert.alert('Disconnected', `Successfully disconnected from ${device.name || 'Unnamed Device'}`);
    } else {
      Alert.alert('Disconnection Failed', `Failed to disconnect from ${device.name || 'Unnamed Device'}`);
    }
  };

  return (
    <View style={styles.card}>
      <View style={styles.infoContainer}>
        <MaterialCommunityIcons name="bluetooth" size={24} color="#4682B4" />
        <Text style={styles.deviceName}>{device.name || 'Unnamed Device'}</Text>
      </View>
      <View style={styles.detailsContainer}>
        <Text style={styles.detailText}>Battery: {device.batteryLevel || 'N/A'}%</Text>
        <Text style={styles.detailText}>Unsynced Data: {device.unsyncedData || '0 MB'}</Text>
      </View>
      <View style={styles.actionsContainer}>
        <TouchableOpacity style={styles.recordButton} onPress={() => Alert.alert('Recording', 'Start Recording functionality to be implemented.')}>
          <Text style={styles.recordButtonText}>Start Recording</Text>
        </TouchableOpacity>
        <TouchableOpacity style={styles.disconnectButton} onPress={handleDisconnect}>
          <Text style={styles.disconnectButtonText}>Disconnect</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: '#F0F8FF',
    padding: 16,
    borderRadius: 10,
    marginBottom: 16,
    elevation: 3, // For Android
    shadowColor: '#000', // For iOS
    shadowOffset: { width: 0, height: 2 }, // For iOS
    shadowOpacity: 0.25, // For iOS
    shadowRadius: 3.84, // For iOS
  },
  infoContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  deviceName: {
    marginLeft: 8,
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  detailsContainer: {
    marginBottom: 12,
  },
  detailText: {
    fontSize: 14,
    color: '#555',
  },
  actionsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  recordButton: {
    backgroundColor: '#32CD32',
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 5,
  },
  recordButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  disconnectButton: {
    backgroundColor: '#FF4500',
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 5,
  },
  disconnectButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/components/AddDeviceModal.js
================================================================================
// app/components/AddDeviceModal.js
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  ActivityIndicator,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useBLE } from '../services/bleServices';

export default function AddDeviceModal({ onClose }) {
  const {
    scanForDevices,
    availableDevices,
    connectToDevice,
    isScanning,
    connectedDevices,
  } = useBLE();

  const [connectingDeviceId, setConnectingDeviceId] = useState(null);

  useEffect(() => {
    scanForDevices();

    return () => {
      // Cleanup if needed when the modal is closed
    };
  }, []);

  const handleConnect = async (device) => {
    setConnectingDeviceId(device.id);
    const success = await connectToDevice(device.id);
    setConnectingDeviceId(null);
    if (success) {
      Alert.alert(
        'Connected',
        `Successfully connected to ${device.name || 'Unnamed Device'}`
      );
      onClose();
    } else {
      Alert.alert(
        'Connection Failed',
        `Failed to connect to ${device.name || 'Unnamed Device'}`
      );
    }
  };

  const renderItem = ({ item }) => {
    const isAlreadyConnected = connectedDevices.some((dev) => dev.id === item.id);
    return (
      <TouchableOpacity
        style={styles.deviceItem}
        onPress={() => handleConnect(item)}
        disabled={isAlreadyConnected || connectingDeviceId === item.id}
      >
        <View style={styles.deviceInfo}>
          <MaterialCommunityIcons name="bluetooth" size={24} color="#4682B4" />
          <Text style={styles.deviceName}>{item.name || 'Unnamed Device'}</Text>
        </View>
        {isAlreadyConnected ? (
          <Text style={styles.connectedText}>Connected</Text>
        ) : connectingDeviceId === item.id ? (
          <ActivityIndicator size="small" color="#4682B4" />
        ) : (
          <Text style={styles.connectText}>Connect</Text>
        )}
      </TouchableOpacity>
    );
  };

  return (
    <SafeAreaView style={styles.modalContainer}>
      <View style={styles.modalContent}>
        <Text style={styles.modalTitle}>Connect to a Device</Text>
        {isScanning ? (
          <ActivityIndicator size="large" color="#4682B4" />
        ) : availableDevices.length === 0 ? (
          <Text style={styles.noDevicesText}>No devices found.</Text>
        ) : (
          <FlatList
            data={availableDevices}
            keyExtractor={(item) => item.id}
            renderItem={renderItem}
          />
        )}
        <TouchableOpacity style={styles.closeButton} onPress={onClose}>
          <MaterialCommunityIcons name="close" size={24} color="#fff" />
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  modalContainer: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '90%',
    maxHeight: '80%',
    backgroundColor: '#fff',
    borderRadius: 10,
    padding: 20,
    elevation: 5, // For Android
    shadowColor: '#000', // For iOS
    shadowOffset: { width: 0, height: 2 }, // For iOS
    shadowOpacity: 0.25, // For iOS
    shadowRadius: 3.84, // For iOS
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  deviceItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginVertical: 10,
  },
  deviceInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  deviceName: {
    marginLeft: 10,
    fontSize: 16,
    color: '#333',
  },
  connectText: {
    color: '#4682B4',
    fontWeight: 'bold',
  },
  connectedText: {
    color: '#32CD32',
    fontWeight: 'bold',
  },
  noDevicesText: {
    textAlign: 'center',
    color: '#888',
    marginVertical: 20,
  },
  closeButton: {
    backgroundColor: '#4682B4',
    padding: 10,
    borderRadius: 5,
    alignSelf: 'center',
    marginTop: 20,
  },
});

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/services/bleServices.js
================================================================================
// app/services/bleServices.js
import React, { createContext, useContext, useEffect, useState } from 'react';
import { Alert, Platform, PermissionsAndroid } from 'react-native';
import { BleManager } from 'react-native-ble-plx';
import { EventEmitter } from 'events';
import { BLE_CHARACTERISTICS } from './ble_characteristics'; // Ensure correct characteristic UUIDs

const BLEContext = createContext();

const BLEServiceUUID = 'A0A43180-96BE-4222-B41E-98EA76B0120C'.toLowerCase();
class BLEService {
  constructor() {
    if (!BLEService.instance) {
      this.manager = new BleManager();
      this.emitter = new EventEmitter();
      this.connectedDevices = [];
      this.availableDevices = [];
      this.isScanning = false;
      this.isDisconnecting = false;
      BLEService.instance = this;

      // Monitor BleManager state changes
      this.manager.onStateChange((state) => {
        console.log('BleManager State:', state);
        if (state === 'PoweredOn') {
          // Ready to scan or perform other operations
        } else {
          // Handle other states (e.g., PoweredOff)
          Alert.alert('Bluetooth Off', 'Please turn on Bluetooth to use this feature.');
        }
      }, true);
    }
    return BLEService.instance;
  }

  // Request necessary permissions
  async requestPermissions() {
    if (Platform.OS === 'android') {
      const permissions = [
        PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
        PermissionsAndroid.PERMISSIONS.BLUETOOTH_SCAN,
        PermissionsAndroid.PERMISSIONS.BLUETOOTH_CONNECT,
      ];

      const granted = await PermissionsAndroid.requestMultiple(permissions);

      const allGranted = permissions.every(
        (perm) => granted[perm] === PermissionsAndroid.RESULTS.GRANTED
      );

      if (!allGranted) {
        Alert.alert('Permissions Required', 'Bluetooth permissions are required to use this feature.');
        return false;
      }
    }
    // iOS permissions are handled by react-native-ble-plx
    return true;
  }

  // Start scanning for devices
  async scanForDevices() {
    const permission = await this.requestPermissions();

    if (!permission) return;

    this.availableDevices = [];
    this.isScanning = true;
    console.log('Starting device scan...');

    this.manager.startDeviceScan(null, null, (error, device) => {
      if (error) {
        console.log('Scan Error:', error);
        Alert.alert('Scan Error', error.message);
        this.isScanning = false;
        this.manager.stopDeviceScan();
        return;
      }

      // Log all discovered devices
      // console.log('Discovered Device:', device);
      // console.log("This line is now printed!");

      // Include all devices, regardless of name
      if (device) {
        const exists = this.availableDevices.find((d) => d.id === device.id);
        if (!exists) {
          this.availableDevices.push(device);
          this.emitter.emit('deviceDiscovered', device);
        }
      }
    });

    // Stop scanning after 10 seconds
    setTimeout(() => {
      this.manager.stopDeviceScan();
      this.isScanning = false;
      console.log('Stopped scanning');
    }, 10000);
  }

  // Connect to a device
  async connectToDevice(deviceId) {
    try {
      console.log(`Connecting to device: ${deviceId}`);
      const device = await this.manager.connectToDevice(deviceId);
      await device.discoverAllServicesAndCharacteristics();
      const batteryLevel = await this.readBatteryLevel(device);
      const unsyncedData = 0; // Dummy data

      const deviceInfo = {
        id: device.id,
        name: device.name,
        batteryLevel,
        unsyncedData,
      };

      this.connectedDevices.push(deviceInfo);
      console.log(`Connected to device: ${device.name || 'Unnamed Device'}`);

      return true;
    } catch (error) {
      console.error('Connection Error:', error);
      Alert.alert('Connection Error', `Failed to connect to device ${deviceId}: ${error.message}`);
      return false;
    }
  }

  // Disconnect from a device
  async disconnectDevice(deviceId) {
    if (this.isDisconnecting) {
      console.log('Already disconnecting.');
      return false;
    }
    this.isDisconnecting = true;
    try {
      console.log(`Disconnecting device: ${deviceId}`);
      await this.manager.cancelDeviceConnection(deviceId);
      this.connectedDevices = this.connectedDevices.filter((dev) => dev.id !== deviceId);
      console.log(`Disconnected from device: ${deviceId}`);
      console.log('Updated Connected Devices:', this.connectedDevices);
      this.isDisconnecting = false;
      return true;
    } catch (error) {
      console.error('Disconnection Error Details:', error);
      Alert.alert('Disconnection Error', `Failed to disconnect from device ${deviceId}: ${error.message}`);
      this.isDisconnecting = false;
      return false;
    }
  }

  // Read Battery Level
  async readBatteryLevel(device) {
    try {
      const services = await device.services();
      const batteryService = services.find(
        (service) => service.uuid.toLowerCase() === BLEServiceUUID
      );
      console.log('Battery Service:', batteryService);
      if (!batteryService) {
        console.log('Battery Service not found');
        return 'N/A';
      }

      const characteristics = await batteryService.characteristics();
      const batteryCharacteristic = characteristics.find(
        (char) => char.uuid.toLowerCase() === BLE_CHARACTERISTICS.battery
      );

      if (!batteryCharacteristic) {
        console.log('Battery Characteristic not found');
        return 'N/A';
      }

      const batteryData = await batteryCharacteristic.read();
      // Decode base64 to binary
      const batteryBytes = Buffer.from(batteryData.value, 'base64');
      const batteryLevel = batteryBytes.readUInt8(0); // Battery Level is a single byte
      console.log(`Battery Level: ${batteryLevel}%`);
      return batteryLevel;
    } catch (error) {
      console.error('Battery Level Read Error:', error);
      return 'N/A';
    }
  }

  // Subscribe to Notifications
  subscribeToNotifications(deviceId, characteristicUUID, onData) {
    this.manager.monitorCharacteristicForDevice(
      deviceId,
      characteristicUUID,
      (error, characteristic) => {
        if (error) {
          console.error('Notification Error:', error);
          return;
        }
        if (characteristic?.value) {
          const data = Buffer.from(characteristic.value, 'base64').toString('ascii');
          onData(data);
        }
      }
    );
  }

  // Start Recording (Dummy Implementation)
  startRecording(deviceId) {
    Alert.alert('Recording Started', `Recording started for device ID: ${deviceId}`);
    // Implement actual recording logic as needed
  }

  // Destroy BleManager instance
  destroy() {
    this.manager.destroy();
    BLEService.instance = null;
  }
}

const instance = new BLEService();
Object.freeze(instance);

export const BLEProvider = ({ children }) => {
  const [availableDevices, setAvailableDevices] = useState([]);
  const [connectedDevices, setConnectedDevices] = useState([]);
  const [isScanning, setIsScanning] = useState(false);

  useEffect(() => {
    // Listen to 'deviceDiscovered' events
    const onDeviceDiscovered = (device) => {
      setAvailableDevices((prevDevices) => {
        const exists = prevDevices.find((d) => d.id === device.id);
        if (!exists) {
          return [...prevDevices, device];
        }
        return prevDevices;
      });
    };

    instance.emitter.on('deviceDiscovered', onDeviceDiscovered);

    return () => {
      instance.emitter.off('deviceDiscovered', onDeviceDiscovered);
      instance.destroy(); // Ensure BleManager is destroyed when provider unmounts
    };
  }, []);

  useEffect(() => {
    // Update connectedDevices state whenever instance.connectedDevices changes
    setConnectedDevices([...instance.connectedDevices]);
  }, [instance.connectedDevices]);

  return (
    <BLEContext.Provider
      value={{
        scanForDevices: async () => {
          await instance.scanForDevices();
          setIsScanning(instance.isScanning);
        },
        availableDevices,
        connectToDevice: async (deviceId) => {
          const success = await instance.connectToDevice(deviceId);
          if (success) {
            setConnectedDevices([...instance.connectedDevices]);
          }
          return success;
        },
        disconnectDevice: async (deviceId) => {
          const success = await instance.disconnectDevice(deviceId);
          if (success) {
            setConnectedDevices([...instance.connectedDevices]);
          }
          return success;
        },
        isScanning,
        connectedDevices,
        startRecording: (deviceId) => instance.startRecording(deviceId),
        subscribeToNotifications: (deviceId, characteristicUUID, onData) =>
          instance.subscribeToNotifications(deviceId, characteristicUUID, onData),
      }}
    >
      {children}
    </BLEContext.Provider>
  );
};

export const useBLE = () => {
  return useContext(BLEContext);
};

================================================================================

File: /Users/shiyuanduan/Documents/Expo/stressed-out/app/services/ble_characteristics.js
================================================================================
// app/services/ble_characteristics.js

export const BLE_CHARACTERISTICS = {
  battery: 'A0A43197-96BE-4222-B41E-98EA76B0120C', // Battery Level
  sensorSwitch: 'A0A43193-96BE-4222-B41E-98EA76B0120C', // Sensor Switch
  readData: 'A0A4319F-96BE-4222-B41E-98EA76B0120C', // Read Data
  // Add other characteristics as needed
};

================================================================================

